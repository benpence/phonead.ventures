use futures::future;
use hyper;
use hyper::rt::{Future, Stream};
use std::collections::HashMap;
use url::form_urlencoded;
use url::Url;

use crate::types::*;

/// We need to return different futures depending on the route matched,
/// and we can do that with an enum, such as `futures::Either`, or with
/// trait objects.
///
/// A boxed Future (trait object) is used as it is easier to understand
/// and extend with more types. Advanced users could switch to `Either`.
type BoxFut<I, E> = Box<future::Future<Item = I, Error = E>>;


struct Handler <A, B>
where A: AdventureStateMachine,
      B: CallPlanner,
{
    adventure: A,
    planner: B,
}

impl<A, B> Handler<A, B>
where A: AdventureStateMachine,
      B: CallPlanner,
{
    pub fn handle(&'static mut self, request: &'static hyper::Request<hyper::Body>) -> BoxFut<hyper::Response<hyper::Body>, String> {
        match (request.method(), request.uri().path()) {

            (&hyper::Method::POST, "/") => {
                Box::new(extract_web_params(&request)
                    .and_then(move |web_params| future::result(self.handle_web_params(&web_params))))
            }

            // The 404 Not Found route...
            _ => {
                let mut response = hyper::Response::new(hyper::Body::empty());
                *response.status_mut() = hyper::StatusCode::NOT_FOUND;
                Box::new(future::ok(response))
            },
        }
    }

    fn handle_web_params(&mut self, web_params: &WebParams) -> Result<hyper::Response<hyper::Body>, String> {
        self.planner
            .extract_caller(&web_params)
            .and_then(|caller| self.adventure.next_action(&caller))
            .and_then(|action| self.planner.format_action(&action))
            .map(|output| hyper::Response::new(hyper::Body::from(output)))
    }
}

fn extract_web_params(request: &'static hyper::Request<hyper::Body>) -> BoxFut<WebParams, String> {
    let body = request.clone().body();

    Box::new(body
        // Bunch entire stream into first element
        .concat2()
        // Convert to String errors
        .map_err(|e| e.to_string())
        .map(|chunk| extract_body_params(&chunk))
        .map(move |body_params| {
            let http_headers = request.headers().clone();
            let query_params = extract_query_params(request.uri());

            WebParams {
                http_headers,
                query_params,
                body_params,
            }
    }))
}

fn extract_query_params(uri: &hyper::Uri) -> HashMap<String, String> {
    let url_result = Url::parse(&uri.to_string());

    let query_params_result = url_result.map(|url| {
        url
            .query_pairs()
            .map(|(cow_key, cow_val)| (cow_key.to_string(), cow_val.to_string()))
            .collect::<HashMap<String, String>>()
    });

    query_params_result.unwrap_or(HashMap::new())
}

fn extract_body_params(chunk: &hyper::Chunk) -> HashMap<String, String> {
    let chunks = chunk.iter().cloned().collect::<Vec<u8>>();

    form_urlencoded::parse(chunks.as_ref())
        .into_owned()
        .collect::<HashMap<String, String>>()
}
